{"remainingRequest":"E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\src\\view\\test.vue?vue&type=script&lang=js&","dependencies":[{"path":"E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\src\\view\\test.vue","mtime":1651831714617},{"path":"E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\用户交互技术HCI\\HCIProject0506\\vuePanorama-master\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport axios from 'axios';\nimport * as THREE from \"three\";\nimport * as TrackballControls from 'three-trackballcontrols'\nimport * as ThreeStats from 'three-stats'\nimport { OBJLoader, MTLLoader } from 'three-obj-mtl-loader';\nconst OrbitControls = require('three-orbit-controls')(THREE);\n\nexport default {\n\tprops: {\n\t\tmsg: String\n\t},\n\tdata() {\n\t\treturn {\n\t\t\trenderer: '', //渲染器\n\t\t\tscene: '', //场景\n\t\t\tlight: '', //光源\n\t\t\tcamera: '', //相机\n\t\t\tcontrols: '', //控制器\n\t\t\tstats: '', //性能监控器\n\t\t\tmygroup: '', //模型组\n\n\t\t\taction: '', //控制动画的值\n\t\t\tclock: '', //时钟\n\t\t\tmixer: '', //混合实例\n\t\t\trotateAnimate: '', //旋转动画\n\t\t\tisRotate: 1, //是否开启旋转\n\n\t\t}\n\t},\n\n\tmounted() {\n\t\tthis.init(); //初始化\n\t},\n\n\tmethods: {\n\t\tinit() {\n\t\t\tthis.$refs.threeDom.addEventListener('dblclick', this.onMouseDblclick); //监听双击事件\n\t\t\tthis.rendererInit(); //创建渲染器\n\t\t\tthis.sceneInit(); //创建场景    包含光源和辅助坐标系\n\t\t\tthis.cameraInit(); //创建相机\n\t\t\tthis.controlInit(); //初始化控制器\n\t\t\tthis.propertyInit(); //性能监控\n\t\t\tthis.modelling(); //建立模型\n\t\t},\n\n\t\tmodelling(){ //开始建立模型\n\t\t\tthis.mygroup = new THREE.Group();\n\n\t\t\tvar textureLoader = new THREE.TextureLoader(); //创建纹理贴图\t\t\n\t\t\t//从服务器上取得图片\n\t\t\t// var link='http://192.168.0.170:9001/haems-web/modules/web/images/%E6%AD%A3%E9%9D%A2.png';\t\n\t\t\t//vue加载图表需要用 require形式 从本地取,直接取本地是无法应用上的因为load只支持http协议 打包后变为file协议是无法使用的\n\t\t\t//所以必须取服务上的图片 然后在vue.config中配置跨域\n\t\t\tvar img = textureLoader.load(require('@/assets/img/home3.jpg'));\n\t\t\t//var img = textureLoader.load(link); //vue加载图表需要用 require形式\n\n\t\t\tvar geometry = new THREE.SphereGeometry(130, 256, 256); // 球体网格模型\n\t\t\tvar material = new THREE.MeshLambertMaterial({\n\t\t\t\tmap: img, //设置颜色贴图属性值\n\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t});\n\t\t\tvar meshSphere = new THREE.Mesh(geometry, material); //网格模型对象Mesh\t\n\t\t\tmeshSphere.name = '球体容器';\n\t\t\tthis.mygroup.add(meshSphere);\n\n\t\t\tvar canvasText = this.getcanvers('进门'); //生成一个canvers 文字图案对象\n\t\t\tvar texture = new THREE.CanvasTexture(canvasText);\n\t\t\tvar geometryText = new THREE.PlaneGeometry(16, 10, 60, 60);\n\t\t\tvar materialText = new THREE.MeshPhongMaterial({\n\t\t\t\tmap: texture, // 设置纹理贴图\n\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t});\n\t\t\tvar meshText = new THREE.Mesh(geometryText, materialText);\n\t\t\tmeshText.name = '进门';\n\t\t\tmeshText.position.set(40, 20, -90)\n\t\t\tthis.mygroup.add(meshText);\n\n\t\t\tthis.scene.add(this.mygroup);\n\t\t\tthis.addAnimation(); //添加并开启动画\n\t\t\tthis.refresh();\n\t\t},\n\n\t\tisSpin(val) { //开启和关闭旋转\n\t\t\tif (val == 0) { //关闭控制台\t\t\n\t\t\t\tthis.action.paused = true;\n\t\t\t} else {\n\t\t\t\tthis.action.paused = false;\n\t\t\t}\n\t\t},\n\n\t\taddAnimation() { //添加并开启动画\n\t\t\tthis.clock = new THREE.Clock(); // three.js 时钟对象\n\t\t\tvar times = [0, 3600]; //\t创建帧动画序列\n\t\t\tvar position_x = [0, 360]; //离散属性值\n\t\t\tvar keyframe = new THREE.KeyframeTrack('meshSphere.rotation[y]', times, position_x);\n\t\t\tvar duration = 100; //持续时间\n\t\t\tvar cilp = new THREE.AnimationClip('sphereRotate', duration, [keyframe]); //剪辑 keyframe对象\n\t\t\tthis.mixer = new THREE.AnimationMixer(this.mygroup); //动画混合实例\n\t\t\tthis.action = this.mixer.clipAction(cilp);\n\t\t\tthis.action.timeScale = 1; //播放速度\n\t\t\tthis.action.setLoop(THREE.LoopPingPong).play(); //开始播放 像乒乓球一样在起始点与结束点之间来回循环\n\t\t\tthis.animate(); //开启动画\n\t\t},\n\n\t\tanimate() { //循环渲染\n\t\t\tthis.rotateAnimate = requestAnimationFrame(this.animate);\n\t\t\tthis.renderer.render(this.scene, this.camera);\n\t\t\tthis.update();\n\t\t},\n\n\t\tupdate() { //数据更新\n\t\t\tthis.stats.update();\n\t\t\tthis.mixer.update(this.clock.getDelta());\n\t\t},\n\n\t\trendererInit() { //初始化渲染器\n\t\t\tvar width = 1000; //窗口宽度\n\t\t\tvar height = 800; //窗口高度\n\t\t\tthis.renderer = new THREE.WebGLRenderer(); //创建渲染器\n\t\t\tthis.renderer.setClearColor(0xffffff); //添加背景颜色\n\t\t\tthis.renderer.setSize(width, height); // 设定渲染器尺寸\n\t\t\tthis.$refs.threeDom.appendChild(this.renderer.domElement);\n\t\t},\n\n\t\tsceneInit() { //初始化场景 并向场景添加光源和辅助坐标系\n\t\t\tthis.scene = new THREE.Scene();\n\t\t\tvar ambient = new THREE.AmbientLight(0x444444, 3); //添加光源  颜色和光照强度\n\t\t\tvar axisHelper = new THREE.AxesHelper(600); //添加辅助坐标系\n\t\t\taxisHelper.visible = false;// 新加的\n\t\t\tthis.scene.add(ambient, axisHelper);\n\t\t},\n\n\t\tcameraInit() { //初始化相机\n\t\t\tvar width = 800; //窗口宽度\n\t\t\tvar height = 800; //窗口高度\n\t\t\tthis.camera = new THREE.PerspectiveCamera(90, width / height, 1, 1000); //使用透视相机\n\t\t\tthis.camera.position.set(0, 0, 10); //设置相机位置\n\t\t\tthis.camera.lookAt(new THREE.Vector3(0, 0, 0)); // 相机看向\n\t\t},\n\n\t\tcontrolInit() { //初始化控制器\n\t\t\tthis.controls = new OrbitControls(this.camera, this.$refs.threeDom); // 初始化控制器\n\t\t\tthis.controls.target.set(0, 0, 0); // 设置控制器的焦点，使控制器围绕这个焦点进行旋转\n\t\t\tthis.controls.minDistance = 10; // 设置移动的最短距离（默认为零）\n\t\t\tthis.controls.maxPolarAngle = Math.PI; //绕垂直轨道的距离（范围是0-Math.PI,默认为Math.PI）\n\t\t    this.controls.maxDistance = 30; // 设置移动的最长距离（默认为无穷）\n\t\t\tthis.controls.enablePan = false; //禁用右键功能\n\t\t\tthis.controls.addEventListener('change', this.refresh); //监听鼠标、键盘事件 让整个控件可以拖动\n\t\t},\n\n\t\tpropertyInit() { //初始化性能监控\n\t\t\tthis.stats = new ThreeStats.Stats(); // 创建一个性能监视器\t\n\t\t\tthis.stats.dom.style.position = 'absolute';\n\t\t\tthis.stats.dom.style.top = '-4px';\n\t\t\tthis.$refs.property.appendChild(this.stats.dom);\n\t\t\tthis.stats.update();\n\t\t},\n\n\t\tgetcanvers(text) { //生成一个canvers图案\n\t\t\tvar canvasText = document.createElement(\"canvas\");\n\t\t\tvar c = canvasText.getContext('2d');\n\t\t\t// 矩形区域填充背景\n\t\t\tc.fillStyle = \"#FFFFFF\"; //canver背景\n\t\t\tc.fillRect(0, 0, 300, 200); //生成一个矩形\n\t\t\tc.translate(160, 80);\n\t\t\tc.fillStyle = \"#000000\"; //文本填充颜色\n\t\t\tc.font = \"bold 100px 宋体\"; //字体样式设置\n\t\t\tc.textBaseline = \"middle\"; //文本与\n\t\t\tc.textAlign = \"center\"; //文本居中\n\t\t\tc.fillText(text, 0, 0);\n\n\t\t\tvar texture = new THREE.CanvasTexture(canvasText); //Canvas纹理\n\t\t\tvar geometryText = new THREE.PlaneGeometry(16, 10, 60, 60); //生成一个矩形平面\n\t\t\tvar materialText = new THREE.MeshPhongMaterial({\n\t\t\t\tmap: texture, // 设置纹理贴图\n\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t});\n\t\t\tvar meshText = new THREE.Mesh(geometryText, materialText);\n\t\t\tmeshText.name = text;\n\t\t\tmeshText.position.set(40, 20, -90);\n\t\t\treturn canvasText;\n\t\t},\n\n\t\trefresh(){ //刷新页面 \n\t\t\tthis.renderer.render(this.scene, this.camera); //执行渲染操作\n\t\t\tthis.stats.update(); //更新性能监控的值\t\t\t\n\t\t},\n\n\t\tonMouseDblclick(event) { //触发双击事件\n\t\t\t// 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前\n\t\t\tvar intersects = this.getIntersects(event);\n\t\t\tif (intersects.length != 0) {\n\t\t\t\tfor (var item of intersects) {\n\t\t\t\t\tif (item.object.name != '') { //找到第一个不等于空的模型 就是自定义最近的模型\n\t\t\t\t\t\tthis.action.paused = true; //停止旋转\t\t\t\n\t\t\t\t\t\tthis.$confirm('是否切换场景?', '提示', {\n\t\t\t\t\t\t\tconfirmButtonText: '切换',\n\t\t\t\t\t\t\tcancelButtonText: '取消',\n\t\t\t\t\t\t\ttype: 'warning'\n\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\tthis.action.paused = false; //开启旋转\n\t\t\t\t\t\t\tif (item.object.name == '进门') {\n\t\t\t\t\t\t\t\tthis.changeScene('enter'); //改变页面场景\n\t\t\t\t\t\t\t} else if (item.object.name == '返回') {\n\t\t\t\t\t\t\t\tthis.changeScene('backtrack'); //改变页面场景\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).catch(() => {\n\t\t\t\t\t\t\tthis.action.paused = false; //开启旋转\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { //这里是未选中状态\n\t\t\t}\n\t\t},\n\n\t\tchangeScene(type) {\n\t\t\tvar img = '';\n\t\t\tvar names = '';\n\t\t\tvar canvasText = '';\n\t\t\tvar textureLoader = new THREE.TextureLoader(); //创建纹理贴图\t\t\n\t\t\tif (type == 'enter') {\n\t\t\t\timg = textureLoader.load(require(\"@/assets/img/home1.jpg\")); //vue加载图表需要用 require形式\n\t\t\t\tcanvasText = this.getcanvers('返回'); //生成一个canvers 文字图案对象\t\n\t\t\t\tnames = '返回';\n\t\t\t} else if (type == 'backtrack') { //返回房间\n\t\t\t\timg = textureLoader.load(require(\"@/assets/img/home3.jpg\")); //vue加载图表需要用 require形式\t\n\t\t\t\tcanvasText = this.getcanvers('进门'); //生成一个canvers 文字图案对象\t\n\t\t\t\tnames = '进门';\n\t\t\t}\n\n\t\t\tfor (var item of this.scene.children[2].children) {\n\t\t\t\tif (item.name == '球体容器') { //切换贴图 进入下一张贴图\t\t\t\t\t\n\t\t\t\t\tvar material = new THREE.MeshLambertMaterial({\n\t\t\t\t\t\tmap: img, //设置颜色贴图属性值\n\t\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t\t});\n\t\t\t\t\titem.material = material;\n\t\t\t\t} else if (item.name == '进门' || item.name == '返回') {\n\t\t\t\t\tvar texture = new THREE.CanvasTexture(canvasText);\n\t\t\t\t\tvar materialText = new THREE.MeshPhongMaterial({\n\t\t\t\t\t\tmap: texture, // 设置纹理贴图\n\t\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t\t});\n\n\t\t\t\t\titem.name = names; //改名模型的名字\n\t\t\t\t\titem.material = materialText;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetTimeout(() => { //延迟刷新\n\t\t\t\tthis.refresh();\n\t\t\t}, 100)\n\n\t\t},\n\n\t\tgetIntersects(event) { // 获取与射线相交的对象数组\n\t\t\tevent.preventDefault();\n\t\t\t// 声明 raycaster 和 mouse 变量\n\t\t\tvar raycaster = new THREE.Raycaster(); //生成射线\n\t\t\tvar mouse = new THREE.Vector2();\n\t\t\tvar container = this.$refs.threeDom;\n\t\t\tlet getBoundingClientRect = container.getBoundingClientRect();\n\t\t\t// 通过鼠标点击位置,计算出 raycaster 所需点的位置 分量,以屏幕为中心点,范围 -1 到 1\n\t\t\tmouse.x = ((event.clientX - getBoundingClientRect.left) / container.offsetWidth) * 2 - 1;\n\t\t\tmouse.y = -((event.clientY - getBoundingClientRect.top) / container.offsetHeight) * 2 + 1;\n\t\t\t//通过鼠标点击的位置(二维坐标)和当前相机的矩阵计算出射线位置\n\t\t\traycaster.setFromCamera(mouse, this.camera);\n\t\t\t// 获取与射线相交的对象数组，其中的元素按照距离排序，越近的越靠前\n\t\t\tvar intersects = raycaster.intersectObjects(this.scene.children[2].children);\n\t\t\t//返回选中的对象\n\t\t\treturn intersects;\n\t\t},\n\t}\n}\n",{"version":3,"sources":["test.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"test.vue","sourceRoot":"src/view","sourcesContent":["<template>\n\t<div class=\"homePage\">\n\t\t<el-card class=\"card\">\n\t\t\t<div slot=\"header\">\n\t\t\t\t<div class=\"card-title\">\n\t\t\t\t\t<span>简易版全景图</span>\n\n\t\t\t\t\t<div class=\"card-property\">\n\t\t\t\t\t\t<span ref='property'></span>\n\t\t\t\t\t</div>\n\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"card-content\">\n\t\t\t\t<div ref='threeDom' class=\"model\"></div>\n\t\t\t\t<div class=\"control\">\n\t\t\t\t\t<span class=\"control-title\">控制台</span>\n\t\t\t\t\t<div class=\"control-block\">\n\t\t\t\t\t\t<span class=\"control-block-title\">是否自动旋转</span>\n\t\t\t\t\t\t<el-radio-group v-model=\"isRotate\" @change=\"isSpin\">\n\t\t\t\t\t\t\t<el-radio :label=\"1\">开启</el-radio>\n\t\t\t\t\t\t\t<el-radio :label=\"0\">关闭</el-radio>\n\t\t\t\t\t\t</el-radio-group>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</el-card>\n\t</div>\n</template>\n\n<script>\n\timport axios from 'axios';\n\timport * as THREE from \"three\";\n\timport * as TrackballControls from 'three-trackballcontrols'\n\timport * as ThreeStats from 'three-stats'\n\timport { OBJLoader, MTLLoader } from 'three-obj-mtl-loader';\n\tconst OrbitControls = require('three-orbit-controls')(THREE);\n\n\texport default {\n\t\tprops: {\n\t\t\tmsg: String\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\trenderer: '', //渲染器\n\t\t\t\tscene: '', //场景\n\t\t\t\tlight: '', //光源\n\t\t\t\tcamera: '', //相机\n\t\t\t\tcontrols: '', //控制器\n\t\t\t\tstats: '', //性能监控器\n\t\t\t\tmygroup: '', //模型组\n\n\t\t\t\taction: '', //控制动画的值\n\t\t\t\tclock: '', //时钟\n\t\t\t\tmixer: '', //混合实例\n\t\t\t\trotateAnimate: '', //旋转动画\n\t\t\t\tisRotate: 1, //是否开启旋转\n\n\t\t\t}\n\t\t},\n\n\t\tmounted() {\n\t\t\tthis.init(); //初始化\n\t\t},\n\n\t\tmethods: {\n\t\t\tinit() {\n\t\t\t\tthis.$refs.threeDom.addEventListener('dblclick', this.onMouseDblclick); //监听双击事件\n\t\t\t\tthis.rendererInit(); //创建渲染器\n\t\t\t\tthis.sceneInit(); //创建场景    包含光源和辅助坐标系\n\t\t\t\tthis.cameraInit(); //创建相机\n\t\t\t\tthis.controlInit(); //初始化控制器\n\t\t\t\tthis.propertyInit(); //性能监控\n\t\t\t\tthis.modelling(); //建立模型\n\t\t\t},\n\n\t\t\tmodelling(){ //开始建立模型\n\t\t\t\tthis.mygroup = new THREE.Group();\n\n\t\t\t\tvar textureLoader = new THREE.TextureLoader(); //创建纹理贴图\t\t\n\t\t\t\t//从服务器上取得图片\n\t\t\t\t// var link='http://192.168.0.170:9001/haems-web/modules/web/images/%E6%AD%A3%E9%9D%A2.png';\t\n\t\t\t\t//vue加载图表需要用 require形式 从本地取,直接取本地是无法应用上的因为load只支持http协议 打包后变为file协议是无法使用的\n\t\t\t\t//所以必须取服务上的图片 然后在vue.config中配置跨域\n\t\t\t\tvar img = textureLoader.load(require('@/assets/img/home3.jpg'));\n\t\t\t\t//var img = textureLoader.load(link); //vue加载图表需要用 require形式\n\n\t\t\t\tvar geometry = new THREE.SphereGeometry(130, 256, 256); // 球体网格模型\n\t\t\t\tvar material = new THREE.MeshLambertMaterial({\n\t\t\t\t\tmap: img, //设置颜色贴图属性值\n\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t});\n\t\t\t\tvar meshSphere = new THREE.Mesh(geometry, material); //网格模型对象Mesh\t\n\t\t\t\tmeshSphere.name = '球体容器';\n\t\t\t\tthis.mygroup.add(meshSphere);\n\n\t\t\t\tvar canvasText = this.getcanvers('进门'); //生成一个canvers 文字图案对象\n\t\t\t\tvar texture = new THREE.CanvasTexture(canvasText);\n\t\t\t\tvar geometryText = new THREE.PlaneGeometry(16, 10, 60, 60);\n\t\t\t\tvar materialText = new THREE.MeshPhongMaterial({\n\t\t\t\t\tmap: texture, // 设置纹理贴图\n\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t});\n\t\t\t\tvar meshText = new THREE.Mesh(geometryText, materialText);\n\t\t\t\tmeshText.name = '进门';\n\t\t\t\tmeshText.position.set(40, 20, -90)\n\t\t\t\tthis.mygroup.add(meshText);\n\n\t\t\t\tthis.scene.add(this.mygroup);\n\t\t\t\tthis.addAnimation(); //添加并开启动画\n\t\t\t\tthis.refresh();\n\t\t\t},\n\n\t\t\tisSpin(val) { //开启和关闭旋转\n\t\t\t\tif (val == 0) { //关闭控制台\t\t\n\t\t\t\t\tthis.action.paused = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.action.paused = false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddAnimation() { //添加并开启动画\n\t\t\t\tthis.clock = new THREE.Clock(); // three.js 时钟对象\n\t\t\t\tvar times = [0, 3600]; //\t创建帧动画序列\n\t\t\t\tvar position_x = [0, 360]; //离散属性值\n\t\t\t\tvar keyframe = new THREE.KeyframeTrack('meshSphere.rotation[y]', times, position_x);\n\t\t\t\tvar duration = 100; //持续时间\n\t\t\t\tvar cilp = new THREE.AnimationClip('sphereRotate', duration, [keyframe]); //剪辑 keyframe对象\n\t\t\t\tthis.mixer = new THREE.AnimationMixer(this.mygroup); //动画混合实例\n\t\t\t\tthis.action = this.mixer.clipAction(cilp);\n\t\t\t\tthis.action.timeScale = 1; //播放速度\n\t\t\t\tthis.action.setLoop(THREE.LoopPingPong).play(); //开始播放 像乒乓球一样在起始点与结束点之间来回循环\n\t\t\t\tthis.animate(); //开启动画\n\t\t\t},\n\n\t\t\tanimate() { //循环渲染\n\t\t\t\tthis.rotateAnimate = requestAnimationFrame(this.animate);\n\t\t\t\tthis.renderer.render(this.scene, this.camera);\n\t\t\t\tthis.update();\n\t\t\t},\n\n\t\t\tupdate() { //数据更新\n\t\t\t\tthis.stats.update();\n\t\t\t\tthis.mixer.update(this.clock.getDelta());\n\t\t\t},\n\n\t\t\trendererInit() { //初始化渲染器\n\t\t\t\tvar width = 1000; //窗口宽度\n\t\t\t\tvar height = 800; //窗口高度\n\t\t\t\tthis.renderer = new THREE.WebGLRenderer(); //创建渲染器\n\t\t\t\tthis.renderer.setClearColor(0xffffff); //添加背景颜色\n\t\t\t\tthis.renderer.setSize(width, height); // 设定渲染器尺寸\n\t\t\t\tthis.$refs.threeDom.appendChild(this.renderer.domElement);\n\t\t\t},\n\n\t\t\tsceneInit() { //初始化场景 并向场景添加光源和辅助坐标系\n\t\t\t\tthis.scene = new THREE.Scene();\n\t\t\t\tvar ambient = new THREE.AmbientLight(0x444444, 3); //添加光源  颜色和光照强度\n\t\t\t\tvar axisHelper = new THREE.AxesHelper(600); //添加辅助坐标系\n\t\t\t\taxisHelper.visible = false;// 新加的\n\t\t\t\tthis.scene.add(ambient, axisHelper);\n\t\t\t},\n\n\t\t\tcameraInit() { //初始化相机\n\t\t\t\tvar width = 800; //窗口宽度\n\t\t\t\tvar height = 800; //窗口高度\n\t\t\t\tthis.camera = new THREE.PerspectiveCamera(90, width / height, 1, 1000); //使用透视相机\n\t\t\t\tthis.camera.position.set(0, 0, 10); //设置相机位置\n\t\t\t\tthis.camera.lookAt(new THREE.Vector3(0, 0, 0)); // 相机看向\n\t\t\t},\n\n\t\t\tcontrolInit() { //初始化控制器\n\t\t\t\tthis.controls = new OrbitControls(this.camera, this.$refs.threeDom); // 初始化控制器\n\t\t\t\tthis.controls.target.set(0, 0, 0); // 设置控制器的焦点，使控制器围绕这个焦点进行旋转\n\t\t\t\tthis.controls.minDistance = 10; // 设置移动的最短距离（默认为零）\n\t\t\t\tthis.controls.maxPolarAngle = Math.PI; //绕垂直轨道的距离（范围是0-Math.PI,默认为Math.PI）\n\t\t\t    this.controls.maxDistance = 30; // 设置移动的最长距离（默认为无穷）\n\t\t\t\tthis.controls.enablePan = false; //禁用右键功能\n\t\t\t\tthis.controls.addEventListener('change', this.refresh); //监听鼠标、键盘事件 让整个控件可以拖动\n\t\t\t},\n\n\t\t\tpropertyInit() { //初始化性能监控\n\t\t\t\tthis.stats = new ThreeStats.Stats(); // 创建一个性能监视器\t\n\t\t\t\tthis.stats.dom.style.position = 'absolute';\n\t\t\t\tthis.stats.dom.style.top = '-4px';\n\t\t\t\tthis.$refs.property.appendChild(this.stats.dom);\n\t\t\t\tthis.stats.update();\n\t\t\t},\n\n\t\t\tgetcanvers(text) { //生成一个canvers图案\n\t\t\t\tvar canvasText = document.createElement(\"canvas\");\n\t\t\t\tvar c = canvasText.getContext('2d');\n\t\t\t\t// 矩形区域填充背景\n\t\t\t\tc.fillStyle = \"#FFFFFF\"; //canver背景\n\t\t\t\tc.fillRect(0, 0, 300, 200); //生成一个矩形\n\t\t\t\tc.translate(160, 80);\n\t\t\t\tc.fillStyle = \"#000000\"; //文本填充颜色\n\t\t\t\tc.font = \"bold 100px 宋体\"; //字体样式设置\n\t\t\t\tc.textBaseline = \"middle\"; //文本与\n\t\t\t\tc.textAlign = \"center\"; //文本居中\n\t\t\t\tc.fillText(text, 0, 0);\n\n\t\t\t\tvar texture = new THREE.CanvasTexture(canvasText); //Canvas纹理\n\t\t\t\tvar geometryText = new THREE.PlaneGeometry(16, 10, 60, 60); //生成一个矩形平面\n\t\t\t\tvar materialText = new THREE.MeshPhongMaterial({\n\t\t\t\t\tmap: texture, // 设置纹理贴图\n\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t});\n\t\t\t\tvar meshText = new THREE.Mesh(geometryText, materialText);\n\t\t\t\tmeshText.name = text;\n\t\t\t\tmeshText.position.set(40, 20, -90);\n\t\t\t\treturn canvasText;\n\t\t\t},\n\n\t\t\trefresh(){ //刷新页面 \n\t\t\t\tthis.renderer.render(this.scene, this.camera); //执行渲染操作\n\t\t\t\tthis.stats.update(); //更新性能监控的值\t\t\t\n\t\t\t},\n\n\t\t\tonMouseDblclick(event) { //触发双击事件\n\t\t\t\t// 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前\n\t\t\t\tvar intersects = this.getIntersects(event);\n\t\t\t\tif (intersects.length != 0) {\n\t\t\t\t\tfor (var item of intersects) {\n\t\t\t\t\t\tif (item.object.name != '') { //找到第一个不等于空的模型 就是自定义最近的模型\n\t\t\t\t\t\t\tthis.action.paused = true; //停止旋转\t\t\t\n\t\t\t\t\t\t\tthis.$confirm('是否切换场景?', '提示', {\n\t\t\t\t\t\t\t\tconfirmButtonText: '切换',\n\t\t\t\t\t\t\t\tcancelButtonText: '取消',\n\t\t\t\t\t\t\t\ttype: 'warning'\n\t\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t\tthis.action.paused = false; //开启旋转\n\t\t\t\t\t\t\t\tif (item.object.name == '进门') {\n\t\t\t\t\t\t\t\t\tthis.changeScene('enter'); //改变页面场景\n\t\t\t\t\t\t\t\t} else if (item.object.name == '返回') {\n\t\t\t\t\t\t\t\t\tthis.changeScene('backtrack'); //改变页面场景\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}).catch(() => {\n\t\t\t\t\t\t\t\tthis.action.paused = false; //开启旋转\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { //这里是未选中状态\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tchangeScene(type) {\n\t\t\t\tvar img = '';\n\t\t\t\tvar names = '';\n\t\t\t\tvar canvasText = '';\n\t\t\t\tvar textureLoader = new THREE.TextureLoader(); //创建纹理贴图\t\t\n\t\t\t\tif (type == 'enter') {\n\t\t\t\t\timg = textureLoader.load(require(\"@/assets/img/home1.jpg\")); //vue加载图表需要用 require形式\n\t\t\t\t\tcanvasText = this.getcanvers('返回'); //生成一个canvers 文字图案对象\t\n\t\t\t\t\tnames = '返回';\n\t\t\t\t} else if (type == 'backtrack') { //返回房间\n\t\t\t\t\timg = textureLoader.load(require(\"@/assets/img/home3.jpg\")); //vue加载图表需要用 require形式\t\n\t\t\t\t\tcanvasText = this.getcanvers('进门'); //生成一个canvers 文字图案对象\t\n\t\t\t\t\tnames = '进门';\n\t\t\t\t}\n\n\t\t\t\tfor (var item of this.scene.children[2].children) {\n\t\t\t\t\tif (item.name == '球体容器') { //切换贴图 进入下一张贴图\t\t\t\t\t\n\t\t\t\t\t\tvar material = new THREE.MeshLambertMaterial({\n\t\t\t\t\t\t\tmap: img, //设置颜色贴图属性值\n\t\t\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t\t\t});\n\t\t\t\t\t\titem.material = material;\n\t\t\t\t\t} else if (item.name == '进门' || item.name == '返回') {\n\t\t\t\t\t\tvar texture = new THREE.CanvasTexture(canvasText);\n\t\t\t\t\t\tvar materialText = new THREE.MeshPhongMaterial({\n\t\t\t\t\t\t\tmap: texture, // 设置纹理贴图\n\t\t\t\t\t\t\tside: THREE.DoubleSide, //双面渲染\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\titem.name = names; //改名模型的名字\n\t\t\t\t\t\titem.material = materialText;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsetTimeout(() => { //延迟刷新\n\t\t\t\t\tthis.refresh();\n\t\t\t\t}, 100)\n\n\t\t\t},\n\n\t\t\tgetIntersects(event) { // 获取与射线相交的对象数组\n\t\t\t\tevent.preventDefault();\n\t\t\t\t// 声明 raycaster 和 mouse 变量\n\t\t\t\tvar raycaster = new THREE.Raycaster(); //生成射线\n\t\t\t\tvar mouse = new THREE.Vector2();\n\t\t\t\tvar container = this.$refs.threeDom;\n\t\t\t\tlet getBoundingClientRect = container.getBoundingClientRect();\n\t\t\t\t// 通过鼠标点击位置,计算出 raycaster 所需点的位置 分量,以屏幕为中心点,范围 -1 到 1\n\t\t\t\tmouse.x = ((event.clientX - getBoundingClientRect.left) / container.offsetWidth) * 2 - 1;\n\t\t\t\tmouse.y = -((event.clientY - getBoundingClientRect.top) / container.offsetHeight) * 2 + 1;\n\t\t\t\t//通过鼠标点击的位置(二维坐标)和当前相机的矩阵计算出射线位置\n\t\t\t\traycaster.setFromCamera(mouse, this.camera);\n\t\t\t\t// 获取与射线相交的对象数组，其中的元素按照距离排序，越近的越靠前\n\t\t\t\tvar intersects = raycaster.intersectObjects(this.scene.children[2].children);\n\t\t\t\t//返回选中的对象\n\t\t\t\treturn intersects;\n\t\t\t},\n\t\t}\n\t}\n</script>\n\n<style>\n.homePage {\n\tposition: absolute;\n\theight: 100%;\n\twidth: 100%;\n\tfont-size: 14px;\n\tcolor: #303133;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.card {\n\twidth: 1300px;\n\theight: 900px;\n}\n\n.card-title {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n\n.card-title span {\n\tfont-weight: 600;\n\tfont-size: 18px;\n}\n\n.card-property {\n\t\tposition: relative;\n\t\twidth: 70px;\n\t\theight: 40px;\n\t}\n\n\t.card-content {\n\t\tdisplay: flex;\n\t\tflex-direction: row;\n\t}\n\n\t.model {\n\t\tborder: 1px solid #DCDFE6;\n\t}\n\n\t.control {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\twidth: 300px;\n\t\theight: 800px;\n\t\tborder: 1px solid #DCDFE6;\n\t\tborder-left: none;\n\t}\n\n\t.control-title {\n\t\tfont-size: 18px;\n\t\tfont-weight: 600;\n\t\ttext-align: center;\n\t\tcolor: #409EFF;\n\t\tpadding: 10px;\n\t\tborder-bottom: 1px solid #DCDFE6;\n\t}\n\n\t.control-block {\n\t\tpadding: 10px;\n\t\tborder-bottom: 1px solid #DCDFE6;\n\t}\n\n\t.control-block-title {\n\t\tdisplay: block;\n\t\tmargin-bottom: 5px;\n\t}\n\n\t/* 自定义element样式 */\n\t.el-card__header {\n\t\tpadding: 10px 20px;\n\t}\n</style>\n"]}]}